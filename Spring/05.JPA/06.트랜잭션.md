### 격리 수준
격리 수준
- READ UNCOMMITTED: Dirty Read 발생
- READ COMMITTED: Dirty Read는 허용하지 않지만, Non-Repeatable Read는 허용
- REPEATABLE READ: Non-Repeatable Read는 허용하지 않는것
- SERIALIZABLE: Phantom Read도 허용하지 않는것

에러 케이스
- Dirty Read: 커밋하지 않은 데이터를 읽어오는 문제
- Non-Repeatable Read: 반복해서 데이터를 조회했을 때 같은 데이터를 읽을 수 없는 상태
   - 트랜잭션 1이 회원을 조회 중인데, 트랜잭션 2가 회원을 추가했다고 했다
   - 트랜잭션 1은 다시 회원을 조회할 때, 트랜잭션 2가 추가한 회원을 포함해서 조회하게 된다
- Phantom Read: 반복조회했을 때 결과 집합이 달라지는 것
   - _Non-Repeatable Read와 같은 개념으로 보면 될듯?_ 

JPA
- JPA는 기본적으로 격리수준을 READ COMMITTED 정로도 가정한다
- 서로 다른 트랜잭션에서 동시 수정 문제에 대해서는 기본은 마지막 커밋만 인정된다
   - 최초 커밋을 인정하거나, 총돌 내용에 대해서 병합을 할 수도 있다

### @Version
기능
- 엔티티를 수정할 때마다 버전이 하나씩 증가한다
- 버전은 최초 커밋만 인정하기가 적용된다

예시
- 트랜잭션 1에서 조회한 엔티티를 수정하고 있는데, 트랜잭션 2에서 엔티티를 수정하고 반영했다고 하면 트랜잭션 1을 커밋할 때 버전 정보가 달라서 예외가 발생한다

### JPA 락
추천 전략
- READ COMMITTED + Optimistic Lock

Optimistic Lock
- 특징
   - 버전을 사용해서 락을 관리한다
   - 트랜잭션을 커밋하는 시점에 충돌을 알 수 있다
- 옵션
   - NONE
      - 조회한 엔티티를 수정할 때 다른 트랜잭션에 의해 변경되지 않아야 한다
      - 2개의 트랜잭션에서 같은 값을 수정하는 것을 막을 수 있다
   - OPTIMISTIC
      - 조회한 엔티티는 트랜잭션이 끝날 때까지 다른 트랜잭션에 의해서 변경되지 않아야 한다
      - Dirty Read와 Non-Repeatable Read를 방지한다

Pessimistic Lock
- 특징
   - DB 매커니즘에 의존하는 방법
   - 주로 SQL 쿼리에 select for update 구문을 사용해서 시작한다
   - 엔티티가 아닌 스칼라 타입을 조회할 때도 사용할 수 있다
   - 데이터를 수정하는 즉시 트랜잭션 충돌을 감지할 수 있다
- 옵션
   - PESSIMISTIC_WRITE
      - DB에 쓰기 락을 건다
      - Non-Repeatable READ를 방지한다